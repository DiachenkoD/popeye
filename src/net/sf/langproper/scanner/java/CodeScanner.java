/* Generated By:JavaCC: Do not edit this line. CodeScanner.java */
  /**
  * it should be a fault-tolerant java parser, hopefully
  */

  package net.sf.langproper.scanner.java ;

  import java.io.Reader ;
  import net.sf.langproper.scanner.* ;

  public class CodeScanner implements CodeScannerConstants {
    private static Token memToken ;

    private static TKeyRefList keyList ;
    private static String currentFileName ;  // name of the current file

    public static void main( String args[]) throws ParseException, TokenMgrError
    {
      // no arguments -> read from std-in
      parseFile( args[0] ) ;
    }

    private static void parseFile( String filename ) throws ParseException, TokenMgrError
    {
      System.out.println("java source scanner :  Reading from file " + filename + " . . .");
      try
      {
        CodeScanner parser = new CodeScanner (new java.io.FileInputStream(filename));
        Token t = parser.JavaCompilationUnit() ;

        System.out.println("ready") ;
        System.out.println("Ausgabe : ") ;
        parser.writeOut2(t);

      } catch (java.io.FileNotFoundException e)
      {
          System.out.println("fault-tolerant Java Source Scanner (version 1.0):  File " + filename + " not found.");
          return;
      }
    }

    // ------------------------------------------------------------------------

    public static void setKeyList( TKeyRefList kList)
    {
      keyList = kList ;
    }

    public static TKeyRefList getKeyList()
    {
       return keyList ;
    }

    public static void setCurrentFileName( String filename)
    {
      currentFileName = filename ;
    }

    public static String getCurrentFileName()
    {
      return currentFileName ;
    }

    // ------------------------------------------------------------------------

    // output methode
    private void writeOut2(Token tokenList)
    {
       boolean LeerZeichen = false ;
       boolean Schleife = true ;

       Token t = tokenList ;

       while (t != null)
       {
          System.out.println(t +"#" +t.kind +"#") ;
          t = t.next ;
        }
     }

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
  static final public Token JavaCompilationUnit() throws ParseException {
        Token t = getToken(1);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case LPAREN:
      case RPAREN:
      case BRAKET:
      case APLUS:
      case IDENTIFIER:
      case OTHER:
      case 31:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      Sequence();
    }
    jj_consume_token(0);
            {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public void Sequence() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
      Zahl();
      break;
    case CHARACTER_LITERAL:
    case OTHER:
      Other();
      break;
    case 31:
      List();
      break;
    case APLUS:
      Assign();
      break;
    case BRAKET:
      Bracket();
      break;
    case LPAREN:
      LParen();
      break;
    case RPAREN:
      RParen();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void LParen() throws ParseException {
  Token t = getToken(0) ;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      Zeichen();
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case LPAREN:
    case RPAREN:
    case BRAKET:
    case APLUS:
    case IDENTIFIER:
    case OTHER:
    case 31:
      Sequence();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    memToken =  t ;
  }

  static final public void RParen() throws ParseException {
  memToken = getToken(0) ;
    jj_consume_token(RPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      Zeichen();
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case LPAREN:
    case RPAREN:
    case BRAKET:
    case APLUS:
    case IDENTIFIER:
    case OTHER:
    case 31:
      Sequence();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Bracket() throws ParseException {
  memToken = getToken(0) ;
    jj_consume_token(BRAKET);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      Zeichen();
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case LPAREN:
    case RPAREN:
    case BRAKET:
    case APLUS:
    case IDENTIFIER:
    case OTHER:
    case 31:
      Sequence();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void List() throws ParseException {
  memToken = getToken(0) ;
    jj_consume_token(31);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case LPAREN:
    case RPAREN:
    case BRAKET:
    case APLUS:
    case IDENTIFIER:
    case OTHER:
    case 31:
      Sequence();
      break;
    case STRING_LITERAL:
      Zeichen();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Assign() throws ParseException {
  memToken = getToken(0) ;
    jj_consume_token(APLUS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      Zeichen();
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case LPAREN:
    case RPAREN:
    case BRAKET:
    case APLUS:
    case IDENTIFIER:
    case OTHER:
    case 31:
      Sequence();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Other() throws ParseException {
  memToken = getToken(0) ;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OTHER:
      jj_consume_token(OTHER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        Zeichen();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      break;
    case CHARACTER_LITERAL:
      jj_consume_token(CHARACTER_LITERAL);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Zahl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
      break;
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Zeichen() throws ParseException {
  Token t = getToken(1) ;
    jj_consume_token(STRING_LITERAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
//     System.out.println(t +" from " +memToken) ;
    String str = t.image ;
    if (str != null)
    {
      int len = str.length() ;
      if (len > 2)  // no empty strings like ""
      {
        str = str.substring(1, len -1) ;
        keyList.addKey( str, currentFileName, t.beginLine, t.beginColumn) ;
      }
    }
  }

  static private boolean jj_initialized_once = false;
  static public CodeScannerTokenManager token_source;
  static JavaCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[13];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xcf942000,0xcf942000,0xcfb42000,0x400000,0xcfb42000,0xcfb42000,0xcfb42000,0xcfb42000,0x400000,0x200000,0x40100000,0x42000,0x400000,};
   }

  public CodeScanner(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CodeScannerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public CodeScanner(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CodeScannerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public CodeScanner(CodeScannerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  public void ReInit(CodeScannerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 13; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[32];
    for (int i = 0; i < 32; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 13; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 32; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

  }
